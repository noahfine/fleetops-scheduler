/***** CONFIG *****/
var SHEET_NAME = 'Schedule Matrix';   // tab name
var NAME_ROW = 2;                     // display names
var EMAIL_ROW = 3;                    // emails (can be hidden)
var DATA_START_ROW = 4;               // first row with assignments

// SHARED / TEST CALENDAR ID
var SHARED_CALENDAR_ID = 'INPUT CALENDAR ID';

// Calendar wins for title/date when an event already exists (reflect manual calendar edits)
var CALENDAR_WINS_TITLE_DATE = true;

// Inbound pull cadence (minutes)
var INBOUND_PULL_EVERY_MINUTES = 5;

// Windowed fallback scan if delta-sync not available (for Pull Now / first run)
var PULL_PAST_DAYS = 60;
var PULL_FUTURE_DAYS = 180;

// Delta token auto-roll (recenter the window around “today” every N days)
var DELTA_TOKEN_TTL_DAYS = 30;

// Self-healing watchdog cadence (minutes)
var WATCHDOG_EVERY_MINUTES = 60;

// Invites & markers
var SEND_INVITES = true;              // invite assignees so it lands on their calendars
var CANCEL_TOKEN = 'CANCEL';          // typing this removes that person from the event
var DESC_FOOTER_MARK = 'Managed by Schedule Matrix';
var DESC_FOOTER_PREFIX = '\n\n---\n' + DESC_FOOTER_MARK + ' (Sheets sync)\n';

// Re-creation suppression (prevents deleted events from reappearing too soon)
var RECREATE_SUPPRESS_HOURS = 24;                // TTL to suppress auto-recreate after deletion/removal
var RECREATE_SUPPRESS_PROP  = 'RECREATE_SUPPRESS_MAP_JSON';
var RECREATE_SUPPRESS_MAX   = 5000;              // hard cap to keep storage bounded

// Local change stickiness (blocks inbound overwrites for recent sheet edits)
var CHANGE_STICKY_MINUTES = 10;                  // how long a sheet edit "wins" over inbound
var STICKY_SUPPRESS_PROP  = 'STICKY_SUPPRESS_MAP_JSON';
var STICKY_SUPPRESS_MAX   = 5000;                // cap entries to bound storage

// Windowed fallback clear behavior (safe by verification)
var WINDOW_PULL_VERIFY_WITH_GET_BY_ID = true;         // verify each stale cell via CalendarApp before clearing
var WINDOW_PULL_CLEAR_GUARD = false;                  // we rely on per-cell verification instead of global counts

/***** MENU & SETUP *****/
function onOpen() {
  SpreadsheetApp.getUi()
    .createMenu('Scheduler')
    .addItem('Sync selected row (sheet → cal)', 'syncSelectedRow')
    .addItem('Sync all rows (sheet → cal)', 'syncAllRows')
    .addSeparator()
    .addItem('Enable autosync (install onEdit)', 'enableAutosync')
    .addItem('Disable autosync', 'disableAutosync')
    .addSeparator()
    .addItem('Enable inbound delta pull (cal → sheet)', 'enableInboundPull')
    .addItem('Disable inbound pull', 'disableInboundPull')
    .addItem('Pull now (delta if possible)', 'pullCalendarUpdates')
    .addItem('Run validation sweep now', 'finalValidationSweep_')
    .addItem('Safe cleanup (verify & clear stale)', 'safeCleanupNow')
    .addSeparator()
    .addItem('Reset delta token (full resync)', 'resetDeltaToken')
    .addSeparator()
    .addItem('Enable watchdog', 'enableWatchdog')
    .addItem('Disable watchdog', 'disableWatchdog')
    .addItem('Run watchdog check now', 'watchdogCheckTriggers')
    .addItem('Show trigger status', 'showTriggerStatus')
    .addSeparator()
    .addItem('Debug: Inspect active cell', 'debugInspectActiveCell')
    .addItem('Debug: List all-day events for active row', 'debugListAllDayForActiveRow')
    .addItem('Debug: Show delta status', 'debugShowDeltaStatus')
    .addItem('Debug: Check calendar access', 'debugCheckCalendarAccess')
    .addItem('Force unlink active cell', 'forceUnlinkActiveCell')
    .addToUi();

  ensureTriggersOnOpen_();
}
function setup(){ onOpen(); }

/***** AUTOSYNC (INSTALLABLE onEdit: sheet → calendar, paste-safe, with lock + queue) *****/
function enableAutosync() {
  deleteTriggersByHandler_('onEditHandler');
  ScriptApp.newTrigger('onEditHandler')
    .forSpreadsheet(SpreadsheetApp.getActive())
    .onEdit()
    .create();
  toast_('Autosync enabled (sheet → calendar).');
}
function disableAutosync() {
  var n = deleteTriggersByHandler_('onEditHandler');
  toast_(n ? 'Autosync disabled.' : 'No autosync trigger found.');
}
function onEditHandler(e){
  var lock = LockService.getScriptLock();
  var sh, r1, r2, c1, c2;
  try{
    if(!e || !e.range) return;
    sh = e.range.getSheet();
    if (sh.getName() !== SHEET_NAME) return;

    // Determine bounds without flushing for a fast single-cell path
    r1 = e.range.getRow();
    r2 = e.range.getLastRow ? e.range.getLastRow() : r1;
    c1 = e.range.getColumn();
    c2 = e.range.getLastColumn ? e.range.getLastColumn() : c1;

    // Short lock wait; if busy, queue a near-term retry
    if(!lock.tryLock(300)) {
      queueRowsForSync_(sh.getName(), r1, r2);
      scheduleOneOff_('processPendingEdits_', 0.05); // ~3 seconds
      return;
    }

    // Fast path for single-cell edits inside the data grid
    var isSingleCell = (r1 === r2) && (c1 === c2) && r1 >= DATA_START_ROW && c1 >= 2;
    if (isSingleCell) {
      // Try fast single-cell processing; on failure, queue row and exit
      try {
        var cal = CalendarApp.getCalendarById(SHARED_CALENDAR_ID);
        if (cal) {
          var cell = sh.getRange(r1, c1);
          var dateVal = asDate_(sh.getRange(r1,1).getValue());
          var email = String(getEmailForCol_(sh, c1) || '').trim().toLowerCase();
          if (dateVal && email) {
            var dayStart = new Date(dateVal.getFullYear(), dateVal.getMonth(), dateVal.getDate());
            var dayKeyNow = dateKey_(dayStart);
            var rawValue = (e && Object.prototype.hasOwnProperty.call(e, 'value')) ? String(e.value || '').trim() : String(cell.getValue() || '').trim();
            var note = String(cell.getNote() || '').trim();
            var eventId = parseEventIdFromNote_(note);
            var existingEvent = eventId ? getEventByIdSafe_(cal, eventId) : null;

            if (!rawValue || equalsIgnoreCase_(rawValue, CANCEL_TOKEN)) {
              if (existingEvent) {
                try {
                  var st = existingEvent.getStartTime();
                  var dk = dateKey_(new Date(st.getFullYear(), st.getMonth(), st.getDate()));
                  var tNow = collapseWhitespace_(existingEvent.getTitle() || '');
                  addSuppression_(dk, normalizeKey_(tNow), email, RECREATE_SUPPRESS_HOURS);
                } catch(_) {}
                removeGuestAndDeleteIfEmpty_(existingEvent, email);
              }
              if (note) cell.setNote('');
              // Prevent inbound pull from overriding this clear immediately
              addSticky_(dayKeyNow, email, CHANGE_STICKY_MINUTES);
              return;
            }

            var title = collapseWhitespace_(rawValue);
            var tKey = normalizeKey_(title);
            if (tKey) {
              // If user changed the title and an old linked event still exists, migrate membership instead of
              // snapping the sheet back to the calendar title when CALENDAR_WINS_TITLE_DATE is true.
              var evTitleFast = existingEvent ? collapseWhitespace_(existingEvent.getTitle() || '') : '';
              var evKeyFast   = normalizeKey_(evTitleFast);
              if (existingEvent && tKey !== evKeyFast) {
                // Find or create the target event by the new title
                var migrateTarget = findEventOnDayByTitle_(cal, dayStart, tKey);
                if (!migrateTarget) {
                  migrateTarget = cal.createAllDayEvent(title, dayStart, { description: '', guests: '', sendInvites: SEND_INVITES });
                }
                upsertDescriptionKeepUserContent_(migrateTarget, title);
                if (!hasGuest_(migrateTarget, email)) { try { migrateTarget.addGuest(email); } catch(_) {} }
                var newEvTitleNow = collapseWhitespace_(migrateTarget.getTitle() || '');
                if (String(cell.getValue() || '').trim() !== newEvTitleNow) { cell.setValue(newEvTitleNow); }
                cell.setNote(JSON.stringify({ eventId: canonicalId_(migrateTarget.getId()), titleKey: normalizeKey_(newEvTitleNow), syncedAt: new Date().toISOString() }));
                // Hold cell stable briefly so inbound won't revert
                addSticky_(dayKeyNow, email, CHANGE_STICKY_MINUTES);
                // Remove from the previous event and suppress re-creation for that old title for this guest
                try {
                  var stOld = existingEvent.getStartTime();
                  var dkOld = dateKey_(new Date(stOld.getFullYear(), stOld.getMonth(), stOld.getDate()));
                  addSuppression_(dkOld, evKeyFast, email, RECREATE_SUPPRESS_HOURS);
                } catch(_) {}
                removeGuestAndDeleteIfEmpty_(existingEvent, email);
                return;
              }

              var targetEvent = existingEvent || findEventOnDayByTitle_(cal, dayStart, tKey);
              if (!targetEvent) {
                targetEvent = cal.createAllDayEvent(title, dayStart, { description: '', guests: '', sendInvites: SEND_INVITES });
              }
              upsertDescriptionKeepUserContent_(targetEvent, title);
              if (!hasGuest_(targetEvent, email)) { try { targetEvent.addGuest(email); } catch(_) {} }
              var evTitleNow = collapseWhitespace_(targetEvent.getTitle() || '');
              if (!CALENDAR_WINS_TITLE_DATE && evTitleNow !== title) {
                try { targetEvent.setTitle(title); evTitleNow = title; } catch(_) {}
              }
              if (String(cell.getValue() || '').trim() !== evTitleNow) { cell.setValue(evTitleNow); }
              cell.setNote(JSON.stringify({ eventId: canonicalId_(targetEvent.getId()), titleKey: normalizeKey_(evTitleNow), syncedAt: new Date().toISOString() }));
              // Hold cell stable briefly so inbound won't revert
              addSticky_(dayKeyNow, email, CHANGE_STICKY_MINUTES);
              return;
            }
          }
        }
      } catch(errFast) {
        // Fall through to queue
      }
      queueRowsForSync_(sh.getName(), r1, r1);
      scheduleOneOff_('processPendingEdits_', 0.05);
      return;
    }

    // Fallback for multi-cell/paste edits
    SpreadsheetApp.flush();

    var skipColsSet = {};
    for (var c = c1; c <= c2; c++) skipColsSet[c] = true;

    var start = Math.max(DATA_START_ROW, r1);

    // Mark edited cells as sticky to prevent inbound overwrite while outbound settles
    try {
      var lastColSticky = sh.getLastColumn();
      for (var rr = start; rr <= r2; rr++){
        var dateCellSticky = sh.getRange(rr, 1);
        var sheetDateSticky = asDate_(dateCellSticky.getValue());
        if (!sheetDateSticky) continue;
        var dayKeySticky = dateKey_(new Date(sheetDateSticky.getFullYear(), sheetDateSticky.getMonth(), sheetDateSticky.getDate()));
        for (var cc = Math.max(2, c1); cc <= Math.min(lastColSticky, c2); cc++){
          var emSticky = String(getEmailForCol_(sh, cc) || '').trim().toLowerCase();
          if (!emSticky) continue;
          addSticky_(dayKeySticky, emSticky, CHANGE_STICKY_MINUTES);
        }
      }
    } catch(_){ }
    var created=0, updated=0, deleted=0, mAdd=0, mRem=0, skipped=0, errors=0;

    for (var r = start; r <= r2; r++){
      try{
        var res = syncRowGrouped_(r, skipColsSet);
        created += res.created; updated += res.updated; deleted += res.deleted;
        mAdd += res.membershipsAdded; mRem += res.membershipsRemoved; skipped += res.skipped;
      }catch(err){ errors++; queueRowsForSync_(sh.getName(), r, r); }
    }

    if (errors) scheduleOneOff_('processPendingEdits_', 0.05);

    toast_('Edit sync: rows ' + start + '–' + r2 +
           '  C:' + created + ' U:' + updated + ' D:' + deleted +
           ' +G:' + mAdd + ' -G:' + mRem + (errors ? ' Errors:' + errors : ''));
  }catch(err){
    if (sh && r1 && r2) { queueRowsForSync_(sh.getName(), r1, r2); scheduleOneOff_('processPendingEdits_', 0.05); }
    toast_('onEditHandler error (queued for retry): ' + err);
  }finally{
    try{ lock.releaseLock(); }catch(_){ }
  }
}

/***** INBOUND PULL (time-based trigger: calendar → sheet, with lock) *****/
function enableInboundPull(){
  deleteTriggersByHandler_('pullCalendarUpdates');
  ScriptApp.newTrigger('pullCalendarUpdates')
    .timeBased()
    .everyMinutes(INBOUND_PULL_EVERY_MINUTES)
    .create();
  toast_('Inbound pull enabled (every ' + INBOUND_PULL_EVERY_MINUTES + 'm).');
}
function disableInboundPull(){
  var n = deleteTriggersByHandler_('pullCalendarUpdates');
  toast_(n ? 'Inbound pull disabled.' : 'No inbound trigger found.');
}
function resetDeltaToken(){
  var p = PropertiesService.getScriptProperties();
  p.deleteProperty('CAL_SYNC_TOKEN');
  p.deleteProperty('CAL_SYNC_TOKEN_ISSUED_AT');
  toast_('Delta token reset. Next pull will window-scan and establish a fresh token.');
}
function pullCalendarUpdates(){
  var lock = LockService.getScriptLock();
  try{
    if(!lock.tryLock(5000)) return;

    var props = PropertiesService.getScriptProperties();
    var issuedAt = props.getProperty('CAL_SYNC_TOKEN_ISSUED_AT');
    if (daysSince_(issuedAt) > DELTA_TOKEN_TTL_DAYS) {
      props.deleteProperty('CAL_SYNC_TOKEN');
      props.deleteProperty('CAL_SYNC_TOKEN_ISSUED_AT');
    }

    if (canUseAdvancedCalendar_()){
      try {
        pullCalendarUpdatesDelta_();
        toast_('Inbound pull complete (delta).');
        return;
      } catch(e){
        props.deleteProperty('CAL_SYNC_TOKEN');
        props.deleteProperty('CAL_SYNC_TOKEN_ISSUED_AT');
        try {
          pullCalendarUpdatesWindow_();
          toast_('Inbound pull complete (windowed fallback).');
          return;
        } catch(e2){
          toast_('Pull failed: ' + e2);
          return;
        }
      }
    } else {
      pullCalendarUpdatesWindow_();
      toast_('Inbound pull complete (windowed).');
    }
  } finally {
    try{ lock.releaseLock(); }catch(_){ }
  }
}

/***** ENTRY POINTS (MANUAL) *****/
function syncSelectedRow() {
  var sh = getSheet_();
  var r = sh.getActiveRange().getRow();
  if (r < DATA_START_ROW) return toast_('Select a data row (row >= ' + DATA_START_ROW + ').');
  var res = syncRowGrouped_(r);
  toast_(res.summary);
}
function syncAllRows() {
  var sh = getSheet_();
  var last = sh.getLastRow();
  var created = 0, updated = 0, deleted = 0, membershipsAdded = 0, membershipsRemoved = 0, skipped = 0, errors = 0;
  for (var r = DATA_START_ROW; r <= last; r++) {
    try {
      var res = syncRowGrouped_(r);
      created += res.created; updated += res.updated; deleted += res.deleted;
      membershipsAdded += res.membershipsAdded; membershipsRemoved += res.membershipsRemoved; skipped += res.skipped;
    } catch (e) { errors++; }
  }
  toast_('Done. C:' + created + ' U:' + updated + ' D:' + deleted + ' +G:' + membershipsAdded + ' -G:' + membershipsRemoved + ' S:' + skipped + (errors ? ' Errors:' + errors : ''));
}

/***** CORE: sheet → calendar (ID-first; preserves description; calendar-wins; sheet can move/rename) *****/
function syncRowGrouped_(row, skipColsSet){
  var sh = getSheet_();
  var cal = CalendarApp.getCalendarById(SHARED_CALENDAR_ID);
  var maps = getHeaderMaps_(sh);
  var emails = maps.emails;
  var knownEmailsSet = maps.knownEmailsSet;

  // Don't wipe freshly pasted values in edited columns
  pruneDeletedEventRefsForRow_(row, cal, emails, skipColsSet);

  var dateCell = sh.getRange(row, 1);
  var sheetDate = asDate_(dateCell.getValue());
  if (!sheetDate) return stats_(0,0,0,0,0, countAssignableCells_(sh,row), 'Row ' + row + ': no valid Date; skipped.');

  var lastCol = sh.getLastColumn();
  var created=0, updated=0, deleted=0, membershipsAdded=0, membershipsRemoved=0, skipped=0;
  var rowDayStart = new Date(sheetDate.getFullYear(), sheetDate.getMonth(), sheetDate.getDate());
  var rowDayKey   = dateKey_(rowDayStart);

  var groups = {};     // key -> { displayTitle, members:[{email,cell,event,eventId}], cells:[] }
  var candidates = []; // for possible row relocation if calendar moved date

  for (var c = 2; c <= lastCol; c++){
    var email = (emails[c] || '').trim();
    if (!email) continue; // notes/empty-email columns are free-text

    var cell = sh.getRange(row, c);
    var raw = String(cell.getValue() || '').trim();
    var note = String(cell.getNote() || '').trim();
    var eventId = parseEventIdFromNote_(note);
    var ev = eventId ? getEventByIdSafe_(cal, eventId) : null;

    // Clear / CANCEL
    if (!raw || equalsIgnoreCase_(raw, CANCEL_TOKEN)) {
      if (ev) {
        // Record suppression for this email/day/title to avoid immediate re-add/create
        try{
          var evSt = ev.getStartTime();
          var evDayKey = dateKey_(new Date(evSt.getFullYear(), evSt.getMonth(), evSt.getDate()));
          var evTitleNow = collapseWhitespace_(ev.getTitle()||'');
          addSuppression_(evDayKey, normalizeKey_(evTitleNow), String(email||'').toLowerCase(), RECREATE_SUPPRESS_HOURS);
        }catch(_){/* best-effort */}
        if (removeGuestAndDeleteIfEmpty_(ev, email)) { deleted++; }
        membershipsRemoved++;
      }
      if (note) cell.setNote('');
      // Make this cell sticky so inbound won't re-populate it immediately
      addSticky_(rowDayKey, email.toLowerCase(), CHANGE_STICKY_MINUTES);
      continue;
    }

    // Allow sheet text to move/rename
    var displayTitle, key, dayStartForThis;
    var rawTitle = collapseWhitespace_(raw);
    var rawKey   = normalizeKey_(rawTitle);

    if (ev) {
      var evTitle = collapseWhitespace_(ev.getTitle() || '');
      var evKey   = normalizeKey_(evTitle);
      var evStart = ev.getStartTime();
      var evDayStart = new Date(evStart.getFullYear(), evStart.getMonth(), evStart.getDate());

      if (rawTitle && rawKey !== evKey) {
        var targetEv = findEventOnDayByTitle_(cal, rowDayStart, rawKey);
        if (!targetEv && evDayStart.getTime() !== rowDayStart.getTime()) {
          targetEv = findEventOnDayByTitle_(cal, evDayStart, rawKey);
        }

        if (!targetEv) {
          try { ev.setTitle(rawTitle); evTitle = rawTitle; evKey = rawKey; } catch(_) {}
          displayTitle    = evTitle;
          key             = evKey;
          dayStartForThis = evDayStart;
          candidates.push({cell: cell, email: email, event: ev, wantDay: evDayStart});
        } else {
          displayTitle    = rawTitle;
          key             = rawKey;
          dayStartForThis = rowDayStart;
        }

      } else if (rawTitle && rawKey === evKey && rawTitle !== evTitle) {
        try { ev.setTitle(rawTitle); evTitle = rawTitle; } catch(_) {}
        displayTitle    = evTitle;
        key             = evKey;         // key unchanged
        dayStartForThis = evDayStart;    // keep calendar date
        candidates.push({cell: cell, email: email, event: ev, wantDay: evDayStart});

      } else if (CALENDAR_WINS_TITLE_DATE) {
        displayTitle    = evTitle;
        key             = evKey;
        dayStartForThis = evDayStart;
        candidates.push({cell: cell, email: email, event: ev, wantDay: evDayStart});
      } else {
        displayTitle    = rawTitle;
        key             = rawKey;
        dayStartForThis = rowDayStart;
      }

    } else {
      // No existing event link; sheet text drives
      displayTitle    = rawTitle;
      key             = rawKey;
      dayStartForThis = rowDayStart;
    }

    if (!key) continue;
    if (!groups[key]) groups[key] = { key: key, displayTitle: displayTitle, members: [], cells: [] };
    groups[key].members.push({ email: email, cell: cell, event: ev, eventId: eventId, key: key, displayTitle: displayTitle, wantDay: dayStartForThis });
    groups[key].cells.push(cell);
  }

  // Choose/create canonical event per title key
  var canonicalByKey = {};
  for (var k in groups){
    if (!groups.hasOwnProperty(k)) continue;
    var chosen = null;
    var mems = groups[k].members;
    var targetDay = mems[0].wantDay || rowDayStart;

    // 1) prefer member's existing event with matching title key
    for (var m=0; m<mems.length && !chosen; m++){
      var mev = mems[m].event;
      if (!mev) continue;
      var mevKey = normalizeKey_(collapseWhitespace_(mev.getTitle()||''));
      if (mevKey === k) { chosen = mev; }
    }

    // 2) reuse existing all-day event on target day with this title
    if (!chosen){
      var endDay = new Date(targetDay.getFullYear(), targetDay.getMonth(), targetDay.getDate()+1);
      var matches = cal.getEvents(targetDay, endDay).filter(function(ev2){
        try { return ev2.isAllDayEvent && ev2.isAllDayEvent() &&
                   normalizeKey_(collapseWhitespace_(ev2.getTitle()||'')) === k; }
        catch(e){ return false; }
      });
      if (matches.length) chosen = matches[0];
    }

    // 3) intentionally skip renaming unrelated events; prefer creating a new canonical event

    // 4) otherwise create (respect per-member suppression)
    if (!chosen){
      var anyAllowed = false;
      var targetDayKey = dateKey_(targetDay);
      for (var supIdx=0; supIdx<mems.length && !anyAllowed; supIdx++){
        var emailLowerSup = String(mems[supIdx].email || '').toLowerCase();
        if (!isCreationSuppressed_(targetDayKey, k, emailLowerSup)) anyAllowed = true;
      }
      if (anyAllowed){
        var newDay = targetDay;
        chosen = cal.createAllDayEvent(groups[k].displayTitle || 'Assignment', newDay, {
          description: '',
          guests: '',
          sendInvites: SEND_INVITES
        });
        upsertDescriptionKeepUserContent_(chosen, groups[k].displayTitle);
        created++;
      }
    } else {
      upsertDescriptionKeepUserContent_(chosen, groups[k].displayTitle);
      updated++;
    }
    canonicalByKey[k] = chosen;
  }

  // Reconcile membership & notes
  for (var k2 in groups){
    if (!groups.hasOwnProperty(k2)) continue;
    var canEv = canonicalByKey[k2];
    if (!canEv) continue; // suppressed group
    var canId = canEv.getId();
    var titleFromCal = collapseWhitespace_(canEv.getTitle()||'');

    var desired = {};
    var mems2 = groups[k2].members;
    for (var d=0; d<mems2.length; d++) desired[mems2[d].email.toLowerCase()] = true;

    for (var j=0; j<mems2.length; j++){
      var mbr = mems2[j];
      if (mbr.event && canonicalId_(mbr.event.getId()) !== canonicalId_(canId)){
        if (removeGuestAndDeleteIfEmpty_(mbr.event, mbr.email)) { deleted++; }
        membershipsRemoved++;
      }
      var mbrEmailLower = String(mbr.email||'').toLowerCase();
      var canDay = canEv.getStartTime();
      var canDayKey = dateKey_(new Date(canDay.getFullYear(), canDay.getMonth(), canDay.getDate()));
      // Respect sticky suppression first: if user just edited this cell, don't modify yet
      if (!isStickySuppressed_(canDayKey, mbrEmailLower) && !isCreationSuppressed_(canDayKey, normalizeKey_(titleFromCal), mbrEmailLower)){
        if (!hasGuest_(canEv, mbr.email)) {
          try { canEv.addGuest(mbr.email); membershipsAdded++; } catch(_){ }
        }
        if (String(mbr.cell.getValue()||'').trim() !== titleFromCal){
          mbr.cell.setValue(titleFromCal);
        }
        mbr.cell.setNote(JSON.stringify({ eventId: canonicalId_(canId), titleKey: normalizeKey_(titleFromCal), syncedAt: new Date().toISOString() }));
      }
    }

    // Remove extra assignee-guests (leave external guests)
    var guestsNow = canEv.getGuestList() || [];
    for (var g=0; g<guestsNow.length; g++){
      var ge = (guestsNow[g].getEmail() || '').toLowerCase();
      if (knownEmailsSet[ge] && !desired[ge]) {
        try { canEv.removeGuest(ge); membershipsRemoved++; } catch(_){}
      }
    }

    // If no assignees remain, delete event and clear notes
    if ((canEv.getGuestList() || []).length === 0){
      try { canEv.deleteEvent(); deleted++; } catch(_){}
      for (var x=0; x<mems2.length; x++){ mems2[x].cell.setNote(''); }
    }
  }

  // If calendar moved the event’s date, relocate cells
  var moveMap = {};
  for (var i=0; i<candidates.length; i++){
    var it = candidates[i];
    if (!it.event) continue;
    var id = it.event.getId();
    var want = it.wantDay;
    if (!moveMap[id]) moveMap[id] = { day: want, cells: [] };
    moveMap[id].cells.push(it.cell);
  }
  for (var idKey in moveMap){
    if (!moveMap.hasOwnProperty(idKey)) continue;
    var targetDay = moveMap[idKey].day;
    if (!sameDay_(targetDay, rowDayStart)) {
      var destRow = findOrCreateRowForDate_(targetDay);
      var cols = moveMap[idKey].cells.map(function(c){ return c.getColumn(); });
      for (var z=0; z<cols.length; z++){
        var col = cols[z];
        var fromCell = sh.getRange(row, col);
        var toCell = sh.getRange(destRow, col);
        toCell.setValue(fromCell.getValue());
        toCell.setNote(fromCell.getNote());
        fromCell.setValue('');
        fromCell.setNote('');
      }
    }
  }

  return stats_(created,updated,deleted,membershipsAdded,membershipsRemoved,skipped,
    'Row ' + row + ': C:' + created + ' U:' + updated + ' D:' + deleted + ' +G:' + membershipsAdded + ' -G:' + membershipsRemoved);
}

/***** INBOUND PULL (Calendar → Sheet): delta first, windowed fallback; auto-roll token *****/
function pullCalendarUpdatesDelta_(){
  var sh = getSheet_();
  var calId = SHARED_CALENDAR_ID;

  // Batch read sheet
  var lastCol = sh.getLastColumn();
  var lastRow = sh.getLastRow();
  var numRows = Math.max(0, lastRow - DATA_START_ROW + 1);
  var dataRange = numRows ? sh.getRange(DATA_START_ROW, 1, numRows, lastCol) : null;
  var values = numRows ? dataRange.getValues() : [];
  var notes  = numRows ? dataRange.getNotes()  : [];
  var dateRowMap = buildDateRowMap_(values);
  var emailColMap = buildEmailColMap_(sh, lastCol);
  var eventIndex = buildEventIdIndex_(notes);

  var props = PropertiesService.getScriptProperties();
  var token = props.getProperty('CAL_SYNC_TOKEN');

  var params = {
    maxResults: 2500,
    singleEvents: true,
    showDeleted: true
  };

  if (token) {
    params.syncToken = token;
  } else {
    var now = new Date();
    params.timeMin = new Date(now.getFullYear(), now.getMonth(), now.getDate() - PULL_PAST_DAYS).toISOString();
    params.timeMax = new Date(now.getFullYear(), now.getMonth(), now.getDate() + PULL_FUTURE_DAYS + 1).toISOString();
  }

  var pageToken = null;

  do {
    if (pageToken) params.pageToken = pageToken;
    var resp = Calendar.Events.list(calId, params);
    if (!resp || !resp.items) break;

    for (var i=0; i<resp.items.length; i++){
      var ev = resp.items[i];
      var evId = canonicalId_(ev.id);

      if (ev.status === 'cancelled'){
        var locs = eventIndex[evId] || [];
        for (var k=0; k<locs.length; k++){
          var p = locs[k];
          values[p.r0][p.c0] = '';
          notes[p.r0][p.c0] = '';
        }
        // Record suppression to avoid immediate re-creation after deletion
        try {
          var dayKeyCancelled = ev.start && ev.start.date ? ev.start.date : null;
          var titleCancelled = String(ev.summary || '').trim();
          var titleKeyCancelled = normalizeKey_(titleCancelled);
          var attendeesCancelled = ev.attendees || [];
          if (dayKeyCancelled && attendeesCancelled.length){
            for (var ai=0; ai<attendeesCancelled.length; ai++){
              var eml = String(attendeesCancelled[ai].email || '').toLowerCase();
              if (eml) addSuppression_(dayKeyCancelled, titleKeyCancelled, eml, RECREATE_SUPPRESS_HOURS);
            }
          }
        } catch(_){/* best-effort */}
        continue;
      }

      // Only all-day events
      var isAllDay = !!(ev.start && (ev.start.date || ev.start.dateTime === undefined));
      if (!isAllDay) continue;

      var dayKey = ev.start && ev.start.date ? ev.start.date : null;
      if (!dayKey) continue;

      var attendees = ev.attendees || [];
      var title = String(ev.summary || '').trim();
      var titleKey = normalizeKey_(title);

      var attendeeSet = {};
      for (var a=0; a<attendees.length; a++){
        var em = (attendees[a].email || '').toLowerCase();
        if (em) attendeeSet[em] = true;
      }

      var rowIndex = ensureRowInArrays_(sh, values, notes, dateRowMap, dayKey);

      for (var emailLower in attendeeSet){
        if (!attendeeSet.hasOwnProperty(emailLower)) continue;
        // Respect sticky suppression first: user's recent sheet edit should not be overridden
        if (isStickySuppressed_(dayKey, emailLower)) continue;
        // Respect re-creation suppression to avoid resurrecting recently-deleted assignments during eventual consistency
        if (isCreationSuppressed_(dayKey, titleKey, emailLower)) continue;
        var col = emailColMap[emailLower];
        if (!col) continue;
        var c0 = col - 1;
        values[rowIndex][c0] = title;
        notes[rowIndex][c0] = JSON.stringify({ eventId: canonicalId_(evId), titleKey: titleKey, syncedAt: new Date().toISOString() });
      }

      // Clear old locations for this evId (safe with delta)
      var locs3 = eventIndex[evId] || [];
      for (var q=0; q<locs3.length; q++){
        var p3 = locs3[q];
        var colEmail = getEmailForCol_(sh, p3.c0 + 1);
        var emailLower3 = (colEmail || '').toLowerCase();
        if (!attendeeSet[emailLower3] || rowIndex !== p3.r0){
          values[p3.r0][p3.c0] = '';
          notes[p3.r0][p3.c0] = '';
        }
      }
    }

    pageToken = resp.nextPageToken || null;
    if (resp.nextSyncToken){
      props.setProperty('CAL_SYNC_TOKEN', resp.nextSyncToken);
      props.setProperty('CAL_SYNC_TOKEN_ISSUED_AT', new Date().toISOString());
    }
  } while(pageToken);

  writeBackArrays_(sh, values, notes, lastCol);
  finalValidationSweep_();
}

// >>> SAFE WINDOWED FALLBACK (verification-based clears) <<<
function pullCalendarUpdatesWindow_(){
  var sh = getSheet_();

  // Batch read sheet
  var lastCol = sh.getLastColumn();
  var lastRow = sh.getLastRow();
  var numRows = Math.max(0, lastRow - DATA_START_ROW + 1);
  var dataRange = numRows ? sh.getRange(DATA_START_ROW, 1, numRows, lastCol) : null;
  var values = numRows ? dataRange.getValues() : [];
  var notes  = numRows ? dataRange.getNotes()  : [];

  var dateRowMap = buildDateRowMap_(values);
  var emailColMap = buildEmailColMap_(sh, lastCol);
  var eventIndex = buildEventIdIndex_(notes);

  var today = new Date();
  var start = new Date(today.getFullYear(), today.getMonth(), today.getDate() - PULL_PAST_DAYS);
  var end   = new Date(today.getFullYear(), today.getMonth(), today.getDate() + PULL_FUTURE_DAYS + 1);

  var calApp = CalendarApp.getCalendarById(SHARED_CALENDAR_ID);
  var evs = calApp.getEvents(start, end);
  var allDay = [];
  for (var i=0; i<evs.length; i++){
    try { if (evs[i].isAllDayEvent && evs[i].isAllDayEvent()) allDay.push(evs[i]); } catch(e){}
  }

  // Build by-date map
  var byDate = {};
  for (var j=0; j<allDay.length; j++){
    var ev = allDay[j];
    var st = ev.getStartTime();
    var dk = dateKey_(st);
    if (!byDate[dk]) byDate[dk] = [];
    byDate[dk].push(ev);
  }

  // snapshot sanity: if zero events but window has populated rows, skip clearing this run
  var populatedInWindow = 0;
  for (var r0=0; r0<values.length; r0++){
    var dv = asDate_(values[r0][0]);
    if (!dv) continue;
    if (dv.getTime() >= start.getTime() && dv.getTime() < end.getTime()){
      for (var c0=1; c0<lastCol; c0++){
        if (String(values[r0][c0]||'').trim() || String(notes[r0][c0]||'').trim()) { populatedInWindow++; break; }
      }
    }
  }
  var suspiciousEmpty = (allDay.length === 0 && populatedInWindow > 0);

  // Fill from calendar snapshot
  var keep = {}; // "r0,c0" entries that remain populated
  for (var dk2 in byDate){
    if (!byDate.hasOwnProperty(dk2)) continue;
    var rowIndex = ensureRowInArrays_(sh, values, notes, dateRowMap, dk2);
    var dayEvents = byDate[dk2];
    for (var eIdx=0; eIdx<dayEvents.length; eIdx++){
      var ev2 = dayEvents[eIdx];
      var title = collapseWhitespace_(ev2.getTitle() || '');
      var titleKey = normalizeKey_(title);
      var guests = ev2.getGuestList() || [];

      for (var g=0; g<guests.length; g++){
        var em = (guests[g].getEmail() || '').toLowerCase();
        // Respect sticky suppression first: user's recent sheet edit should not be overridden
        if (isStickySuppressed_(dk2, em)) continue;
        // Respect re-creation suppression to avoid resurrecting recently-deleted assignments during eventual consistency
        if (isCreationSuppressed_(dk2, titleKey, em)) continue;
        var col = emailColMap[em];
        if (!col) continue;
        var c0 = col - 1;
        values[rowIndex][c0] = title;
        notes[rowIndex][c0] = JSON.stringify({ eventId: canonicalId_(ev2.getId()), titleKey: titleKey, syncedAt: new Date().toISOString() });
        keep[rowIndex + ',' + c0] = true;
      }
    }
  }

  // Carefully clear stale cells INSIDE THE WINDOW (verification-based)
  if (!suspiciousEmpty){
    for (var evId in eventIndex){
      if (!eventIndex.hasOwnProperty(evId)) continue;
      var locs = eventIndex[evId];
      for (var p=0; p<locs.length; p++){
        var r0 = locs[p].r0, c0 = locs[p].c0;

        var rowDate = asDate_(values[r0] ? values[r0][0] : null);
        if (!rowDate) continue;
        if (!(rowDate.getTime() >= start.getTime() && rowDate.getTime() < end.getTime())) continue;

        var key = r0 + ',' + c0;
        if (keep[key]) continue; // this cell was confirmed by snapshot

        var emailLower = String(getEmailForCol_(sh, c0+1) || '').trim().toLowerCase();
        var okToClear = false;

        if (WINDOW_PULL_VERIFY_WITH_GET_BY_ID){
          var evObj = getEventByIdSafe_(calApp, evId);
          var rowDayKey = dateKey_(rowDate);

          if (evObj){
            // If event exists: clear only if person not guest OR event moved date
            if (!hasGuest_(evObj, emailLower)) okToClear = true;
            else {
              var st2 = evObj.getStartTime();
              var evDayKey = dateKey_(new Date(st2.getFullYear(), st2.getMonth(), st2.getDate()));
              if (evDayKey !== rowDayKey) okToClear = true;
            }
          } else {
            // Could be deleted… or service hiccup. Be conservative:
            // Look for ANY all-day event on that date that still includes this guest.
            var dayEvents2 = getAllDayEventsOn_(calApp, rowDate);
            var guestStillOnSomeEvent = false;
            for (var ii=0; ii<dayEvents2.length; ii++){
              if (hasGuest_(dayEvents2[ii], emailLower)) { guestStillOnSomeEvent = true; break; }
            }
            okToClear = !guestStillOnSomeEvent; // clear only if we cannot find them on any event that day
          }
        } else {
          // Legacy behavior (not recommended): clear when absent from snapshot
          okToClear = true;
        }

        if (okToClear){
          // Record suppression to avoid immediate re-create on next outbound pass
          try{
            var rowDayKey2 = dateKey_(rowDate);
            var tKeyFromNote = parseTitleKeyFromNote_(notes[r0][c0]);
            if (tKeyFromNote && emailLower){ addSuppression_(rowDayKey2, tKeyFromNote, emailLower, RECREATE_SUPPRESS_HOURS); }
          }catch(_){/* best-effort */}
          values[r0][c0] = '';
          notes[r0][c0]  = '';
        }
      }
    }
  }

  writeBackArrays_(sh, values, notes, lastCol);

  // Establish delta token so next pulls are incremental
  try {
    var params = {
      maxResults: 1,
      singleEvents: true,
      showDeleted: true,
      timeMin: start.toISOString(),
      timeMax: end.toISOString()
    };
    var resp = Calendar.Events.list(SHARED_CALENDAR_ID, params);
    if (resp && resp.nextSyncToken){
      var props = PropertiesService.getScriptProperties();
      props.setProperty('CAL_SYNC_TOKEN', resp.nextSyncToken);
      props.setProperty('CAL_SYNC_TOKEN_ISSUED_AT', new Date().toISOString());
    }
  } catch(e) {
    // ignore if advanced service not enabled yet
  }

  finalValidationSweep_();
}

/***** VALIDATION SWEEP (no destructive clears on uncertainty) *****/
function finalValidationSweep_() {
  var sh = getSheet_();
  var cal = CalendarApp.getCalendarById(SHARED_CALENDAR_ID);
  var lastCol = sh.getLastColumn();
  var lastRow = sh.getLastRow();
  var numRows = Math.max(0, lastRow - DATA_START_ROW + 1);
  if (!numRows) return;

  var rng = sh.getRange(DATA_START_ROW, 1, numRows, lastCol);
  var values = rng.getValues();
  var notes  = rng.getNotes();
  var emailRow = sh.getRange(EMAIL_ROW, 1, 1, lastCol).getValues()[0];

  for (var r0 = 0; r0 < values.length; r0++) {
    var rowDate = asDate_(values[r0][0]);
    var rowDayKey = rowDate ? dateKey_(rowDate) : null;
    for (var c0 = 1; c0 < lastCol; c0++) {
      var note = String(notes[r0][c0] || '').trim();
      if (!note) continue;
      var evId = parseEventIdFromNote_(note);
      if (!evId) { notes[r0][c0] = ''; continue; }

      var ev = getEventByIdSafe_(cal, evId);
      if (!ev) { /* don't clear here; leave for pull/cleanup */ continue; }

      var email = String(emailRow[c0] || '').trim().toLowerCase();
      if (!email) continue;

      // Do not overwrite cells that are currently sticky (recent local edits)
      if (rowDayKey && isStickySuppressed_(rowDayKey, email)) { continue; }

      if (!hasGuest_(ev, email)) { values[r0][c0] = ''; notes[r0][c0] = ''; continue; }

      var st = ev.getStartTime();
      var evDayKey = dateKey_(new Date(st.getFullYear(), st.getMonth(), st.getDate()));
      if (rowDayKey && evDayKey !== rowDayKey) { values[r0][c0] = ''; notes[r0][c0] = ''; continue; }

      var t = collapseWhitespace_(ev.getTitle() || '');
      if (String(values[r0][c0] || '').trim() !== t) values[r0][c0] = t;
      notes[r0][c0] = JSON.stringify({ eventId: canonicalId_(ev.getId()), titleKey: normalizeKey_(t), syncedAt: new Date().toISOString() });
    }
  }

  rng.setValues(values);
  rng.setNotes(notes);
}

/***** SAFE CLEANUP (manual verify & clear stale) *****/
function safeCleanupNow(){
  var sh = getSheet_();
  var cal = CalendarApp.getCalendarById(SHARED_CALENDAR_ID);
  var lastCol = sh.getLastColumn();
  var lastRow = sh.getLastRow();
  var numRows = Math.max(0, lastRow - DATA_START_ROW + 1);
  if (!numRows) { toast_('Nothing to clean.'); return; }

  var rng = sh.getRange(DATA_START_ROW, 1, numRows, lastCol);
  var values = rng.getValues();
  var notes  = rng.getNotes();
  var emailRow = sh.getRange(EMAIL_ROW, 1, 1, lastCol).getValues()[0];

  var cleared = 0, verified = 0;

  for (var r0 = 0; r0 < values.length; r0++) {
    var rowDate = asDate_(values[r0][0]);
    if (!rowDate) continue;
    var rowDayKey = dateKey_(rowDate);

    for (var c0 = 1; c0 < lastCol; c0++) {
      var n = String(notes[r0][c0] || '').trim();
      if (!n) continue;
      var evId = parseEventIdFromNote_(n);
      if (!evId) { notes[r0][c0] = ''; continue; }

      var email = String(emailRow[c0] || '').trim().toLowerCase();
      if (!email) continue;

      var ev = getEventByIdSafe_(cal, evId);
      if (ev){
        verified++;
        if (!hasGuest_(ev, email)) { values[r0][c0]=''; notes[r0][c0]=''; cleared++; continue; }
        var st = ev.getStartTime();
        var evDayKey = dateKey_(new Date(st.getFullYear(), st.getMonth(), st.getDate()));
        if (evDayKey !== rowDayKey) { values[r0][c0]=''; notes[r0][c0]=''; cleared++; continue; }
      } else {
        // event not found: before clearing, check any all-day event for this email on this date
        var dayEvents = getAllDayEventsOn_(cal, rowDate);
        var guestStillOnSomeEvent = false;
        for (var ii=0; ii<dayEvents.length; ii++){
          if (hasGuest_(dayEvents[ii], email)) { guestStillOnSomeEvent = true; break; }
        }
        if (!guestStillOnSomeEvent) { values[r0][c0]=''; notes[r0][c0]=''; cleared++; }
      }
    }
  }

  rng.setValues(values);
  rng.setNotes(notes);
  toast_('Safe cleanup done. Verified:'+verified+'  Cleared:'+cleared);
}

/***** WATCHDOG (self-heal triggers) *****/
function ensureTriggersOnOpen_(){
  var needAutosync = !hasTrigger_('onEditHandler');
  var needInbound  = !hasTrigger_('pullCalendarUpdates');

  if (needAutosync) enableAutosync();
  if (needInbound)  enableInboundPull();
}
function enableWatchdog(){
  deleteTriggersByHandler_('watchdogCheckTriggers');
  ScriptApp.newTrigger('watchdogCheckTriggers')
    .timeBased()
    .everyMinutes(WATCHDOG_EVERY_MINUTES)
    .create();
  toast_('Watchdog enabled (every ' + WATCHDOG_EVERY_MINUTES + 'm).');
}
function disableWatchdog(){
  var n = deleteTriggersByHandler_('watchdogCheckTriggers');
  toast_(n ? 'Watchdog disabled.' : 'No watchdog trigger found.');
}
function watchdogCheckTriggers(){
  var fixed = [];
  if (!hasTrigger_('onEditHandler')) { enableAutosync(); fixed.push('onEdit'); }
  if (!hasTrigger_('pullCalendarUpdates')) { enableInboundPull(); fixed.push('inbound pull'); }
  toast_(fixed.length ? ('Watchdog: restored ' + fixed.join(', ') + '.') : 'Watchdog: all good.');
}
function showTriggerStatus(){
  var names = getTriggerHandlersPresent_();
  toast_('Active triggers: ' + (names.length ? names.join(', ') : '(none)'));
}
function hasTrigger_(handler){
  var t = ScriptApp.getProjectTriggers();
  for (var i=0;i<t.length;i++){ if (t[i].getHandlerFunction() === handler) return true; }
  return false;
}
function getTriggerHandlersPresent_(){
  var t = ScriptApp.getProjectTriggers(), out=[];
  for (var i=0;i<t.length;i++){ out.push(t[i].getHandlerFunction()); }
  return out;
}

/***** QUEUE + RETRY *****/
function queueRowsForSync_(sheetName, r1, r2){
  if (r2 < DATA_START_ROW) return;
  r1 = Math.max(r1, DATA_START_ROW);

  var props = PropertiesService.getScriptProperties();
  var raw = props.getProperty('PENDING_ROWS_JSON') || '{}';
  var obj = {};
  try{ obj = JSON.parse(raw) || {}; }catch(_){ obj = {}; }

  var key = sheetName;
  var set = obj[key] || {};
  for (var r = r1; r <= r2; r++){ set[String(r)] = true; }
  obj[key] = set;

  props.setProperty('PENDING_ROWS_JSON', JSON.stringify(obj));
}
function scheduleOneOff_(handler, minutes){
  var t = ScriptApp.getProjectTriggers();
  for (var i=0;i<t.length;i++){
    if (t[i].getHandlerFunction() === handler && t[i].getTriggerSource() === ScriptApp.TriggerSource.CLOCK) return;
  }
  ScriptApp.newTrigger(handler).timeBased().after(minutes*60*1000).create();
}
function processPendingEdits_(){
  var lock = LockService.getScriptLock();
  try{
    if(!lock.tryLock(5000)) return;

    var props = PropertiesService.getScriptProperties();
    var raw = props.getProperty('PENDING_ROWS_JSON') || '{}';
    var obj = {};
    try{ obj = JSON.parse(raw) || {}; }catch(_){ obj = {}; }

    var sh = getSheet_();
    var name = sh.getName();
    var set = obj[name] || {};
    var rows = Object.keys(set).map(function(k){ return Number(k); }).sort(function(a,b){ return a-b; });

    if (!rows.length) return;

    var created=0, updated=0, deleted=0, mAdd=0, mRem=0, skipped=0, errors=0;

    var lastCol = sh.getLastColumn();
    var skipColsSet = {}; for (var c = 2; c <= lastCol; c++) skipColsSet[c] = true;

    for (var i=0;i<rows.length;i++){
      var r = rows[i];
      try{
        var res = syncRowGrouped_(r, skipColsSet);
        created += res.created; updated += res.updated; deleted += res.deleted;
        mAdd += res.membershipsAdded; mRem += res.membershipsRemoved; skipped += res.skipped;
        delete set[String(r)];
      }catch(err){ errors++; }
    }

    obj[name] = set;
    props.setProperty('PENDING_ROWS_JSON', JSON.stringify(obj));

    toast_('Processed queued edits: ' + rows.length +
           '  C:' + created + ' U:' + updated + ' D:' + deleted +
           ' +G:' + mAdd + ' -G:' + mRem + (errors ? ' Errors:' + errors : ''));
  } finally {
    try{ lock.releaseLock(); }catch(_){ }
  }
}

/***** DEBUG TOOLS *****/
function debugCheckCalendarAccess() {
  var id = SHARED_CALENDAR_ID;
  var cal = CalendarApp.getCalendarById(id);
  if (!cal) throw new Error('Calendar not found or no access: ' + id);
  var today = new Date();
  var title = 'TEMP ACCESS TEST - safe to delete';
  var ev = cal.createAllDayEvent(title, today);
  ev.deleteEvent();
  toast_('Calendar access OK.');
}
function debugInspectActiveCell(){
  var sh = getSheet_();
  var r  = sh.getActiveRange();
  var row = r.getRow(), col = r.getColumn();
  var emails = getHeaderMaps_(sh).emails;
  var email = (emails[col] || '').trim().toLowerCase();
  var val   = String(sh.getRange(row,col).getValue()||'').trim();
  var note  = String(sh.getRange(row,col).getNote()||'').trim();
  var evId  = parseEventIdFromNote_(note);
  var cal   = CalendarApp.getCalendarById(SHARED_CALENDAR_ID);
  var ev    = getEventByIdSafe_(cal, evId);
  var exists = !!ev;

  var guestState='n/a', evDate='n/a', guestList='';
  if (ev){
    guestState = hasGuest_(ev, email) ? 'guest=YES' : 'guest=NO';
    var st = ev.getStartTime();
    evDate = dateKey_(new Date(st.getFullYear(), st.getMonth(), st.getDate()));
    var gl = ev.getGuestList() || [];
    var arr = [];
    for (var i=0;i<gl.length;i++){ arr.push((gl[i].getEmail()||'').toLowerCase()); }
    guestList = arr.join(',');
  }
  toast_(
    'Cell ('+row+','+col+') email='+email+' title="'+val+
    '" id='+(evId||'')+' exists='+exists+' '+guestState+' evDate='+evDate+
    ' cal='+SHARED_CALENDAR_ID
  );
  if (guestList) Logger.log('Guests: '+guestList);
}
function debugListAllDayForActiveRow(){
  try{
    var sh = getSheet_();
    var r = sh.getActiveRange().getRow();
    if (r < DATA_START_ROW) return toast_('Select a data row (row >= ' + DATA_START_ROW + ').');
    var v = asDate_(sh.getRange(r,1).getValue());
    if (!v) return toast_('No valid date in column A for row ' + r + '.');
    var dayStart = new Date(v.getFullYear(), v.getMonth(), v.getDate());
    var dayEnd   = new Date(v.getFullYear(), v.getMonth(), v.getDate()+1);

    var cal = CalendarApp.getCalendarById(SHARED_CALENDAR_ID);
    var evs = cal.getEvents(dayStart, dayEnd);
    var lines = [];
    lines.push('Shared calendar: ' + SHARED_CALENDAR_ID);
    lines.push('Date: ' + dayStart.toDateString());
    lines.push('All-day events on this date:');

    var count = 0;
    for (var i=0; i<evs.length; i++){
      var ev = evs[i];
      try{
        if (!(ev.isAllDayEvent && ev.isAllDayEvent())) continue;
        count++;
        var title = ev.getTitle() || '';
        var id = ev.getId() || '';
        var guests = ev.getGuestList() || [];
        var emails = [];
        for (var g=0; g<guests.length; g++){
          emails.push((guests[g].getEmail()||'').toLowerCase());
        }
        lines.push('  • ' + title + '  [id=' + id + ']  guests=' + emails.join(', '));
      }catch(e){}
    }
    if (count === 0) lines.push('  (none)');
    Logger.log(lines.join('\n'));
    toast_('Logged ' + count + ' all-day events for this row. See Executions/Logs.');
  }catch(err){
    toast_('debugListAllDayForActiveRow error: ' + err);
  }
}
function debugShowDeltaStatus(){
  var props = PropertiesService.getScriptProperties();
  var token = props.getProperty('CAL_SYNC_TOKEN');
  var issued = props.getProperty('CAL_SYNC_TOKEN_ISSUED_AT');
  var ageDays = daysSince_(issued);
  Logger.log('Advanced Calendar available: ' + canUseAdvancedCalendar_());
  Logger.log('Delta token present: ' + !!token);
  Logger.log('Issued at: ' + (issued || 'n/a') + ' (ageDays=' + (isFinite(ageDays)? ageDays.toFixed(1) : 'n/a') + ')');
  Logger.log('Window: past=' + PULL_PAST_DAYS + 'd, future=' + PULL_FUTURE_DAYS + 'd');
  toast_('Delta status logged. See Executions/Logs.');
}
function forceUnlinkActiveCell(){
  try{
    var sh = getSheet_();
    var r = sh.getActiveRange();
    var row = r.getRow(), col = r.getColumn();
    if (row < DATA_START_ROW || col < 2) return toast_('Select an assignment cell.');
    var emails = getHeaderMaps_(sh).emails;
    var email = (emails[col] || '').trim().toLowerCase();
    var note  = String(sh.getRange(row,col).getNote()||'').trim();
    var evId  = parseEventIdFromNote_(note);
    if (evId){
      var cal = CalendarApp.getCalendarById(SHARED_CALENDAR_ID);
      var ev  = getEventByIdSafe_(cal, evId);
      if (ev && email && hasGuest_(ev, email)){
        try { ev.removeGuest(email); } catch(_){ }
        if ((ev.getGuestList()||[]).length === 0){
          try { ev.deleteEvent(); } catch(_){ }
        }
      }
    }
    sh.getRange(row,col).setValue('');
    sh.getRange(row,col).setNote('');
    toast_('Cell cleared and unlinked.');
  }catch(e){ toast_('forceUnlinkActiveCell error: ' + e); }
}

/***** DESCRIPTION MERGE *****/
function upsertDescriptionKeepUserContent_(ev, displayTitle){
  var desc = ev.getDescription() || '';
  var cleaned = stripFooter_(desc);
  var footer = DESC_FOOTER_PREFIX + 'Title: ' + (displayTitle || '') + '\n';
  ev.setDescription((cleaned ? cleaned : '') + footer);
}
function stripFooter_(s){
  if (!s) return '';
  var idx = s.indexOf('\n---\n' + DESC_FOOTER_MARK);
  if (idx === -1) idx = s.indexOf('\n\n---\n' + DESC_FOOTER_MARK);
  return idx >= 0 ? s.substring(0, idx).replace(/\s+$/,'') : s;
}

// ===== Sticky suppression helpers (short-term inbound hold after local edit) =====
function stickyKey_(dayKey, emailLower){
  return [String(dayKey||'').trim(), String((emailLower||'').toLowerCase().trim())].join('|');
}
function loadSticky_(){
  try{
    var raw = PropertiesService.getScriptProperties().getProperty(STICKY_SUPPRESS_PROP) || '{}';
    var obj = JSON.parse(raw);
    return obj && typeof obj === 'object' ? obj : {};
  }catch(_){ return {}; }
}
function saveSticky_(obj){
  var now = Date.now();
  var filtered = {};
  var items = [];
  for (var k in obj){
    if (!obj.hasOwnProperty(k)) continue;
    var rec = obj[k] || {};
    var exp = Number(rec.exp)||0;
    if (exp > now){ filtered[k] = { exp: exp }; items.push({ k: k, exp: exp }); }
  }
  if (items.length > STICKY_SUPPRESS_MAX){
    items.sort(function(a,b){ return a.exp - b.exp; });
    var drop = items.length - STICKY_SUPPRESS_MAX;
    for (var i=0; i<drop; i++){
      delete filtered[items[i].k];
    }
  }
  PropertiesService.getScriptProperties().setProperty(STICKY_SUPPRESS_PROP, JSON.stringify(filtered));
}
function addSticky_(dayKey, emailLower, minutes){
  var dk = String(dayKey||'').trim();
  var el = String(emailLower||'').toLowerCase().trim();
  if (!dk || !el) return;
  var map = loadSticky_();
  var ttlMin = Math.max(1, Number(minutes||CHANGE_STICKY_MINUTES));
  map[stickyKey_(dk, el)] = { exp: Date.now() + ttlMin*60000 };
  saveSticky_(map);
}
function isStickySuppressed_(dayKey, emailLower){
  var dk = String(dayKey||'').trim();
  var el = String(emailLower||'').toLowerCase().trim();
  if (!dk || !el) return false;
  var map = loadSticky_();
  var key = stickyKey_(dk, el);
  var rec = map[key];
  if (!rec) return false;
  var now = Date.now();
  var exp = Number(rec.exp)||0;
  if (exp <= now){
    delete map[key];
    saveSticky_(map);
    return false;
  }
  return true;
}

/***** UTILITIES: SHEET BATCH OPS *****/
function getSheet_(){
  var ss = SpreadsheetApp.getActive();
  var sh = ss.getSheetByName(SHEET_NAME);
  if (!sh) throw new Error('Sheet "' + SHEET_NAME + '" not found.');
  return sh;
}
function buildDateRowMap_(values){
  var m = {}; // yyyy-mm-dd -> r0
  for (var r0 = 0; r0 < values.length; r0++){
    var v = asDate_(values[r0][0]);
    if (!v) continue;
    m[dateKey_(v)] = r0;
  }
  return m;
}
function buildEmailColMap_(sh, lastCol){
  var row = EMAIL_ROW;
  var arr = sh.getRange(row, 1, 1, lastCol).getValues()[0];
  var m = {};
  for (var c=2; c<=lastCol; c++){
    var e = String(arr[c-1] || '').trim().toLowerCase();
    if (e) m[e] = c;
  }
  return m;
}
function buildEventIdIndex_(notes){
  var idx = {}; // canonical eventId -> [{r0,c0}]
  for (var r0=0; r0<notes.length; r0++){
    var rowNotes = notes[r0];
    for (var c0=1; c0<rowNotes.length; c0++){
      var n = String(rowNotes[c0] || '').trim();
      if (!n) continue;
      var id = parseEventIdFromNote_(n); // canonical
      if (!id) continue;
      (idx[id] || (idx[id] = [])).push({r0:r0, c0:c0});
    }
  }
  return idx;
}
function ensureRowInArrays_(sh, values, notes, dateRowMap, dayKey){
  if (dateRowMap.hasOwnProperty(dayKey)) return dateRowMap[dayKey];
  var cols = values[0] ? values[0].length : sh.getLastColumn();
  var newVals = new Array(cols); for (var i=0;i<cols;i++) newVals[i] = '';
  var newNotes = new Array(cols); for (var j=0;j<cols;j++) newNotes[j] = '';
  var parts = dayKey.split('-');
  var dayObj = new Date(Number(parts[0]), Number(parts[1])-1, Number(parts[2]));
  newVals[0] = dayObj;
  values.push(newVals);
  notes.push(newNotes);
  var r0 = values.length - 1;
  dateRowMap[dayKey] = r0;
  return r0;
}
function writeBackArrays_(sh, values, notes, lastCol){
  if (!values.length) return;
  var currentRows = Math.max(0, sh.getLastRow() - DATA_START_ROW + 1);
  var need = values.length - currentRows;
  if (need > 0){
    sh.insertRowsAfter(DATA_START_ROW + currentRows - 1, need);
  }
  var rng = sh.getRange(DATA_START_ROW, 1, values.length, lastCol);
  rng.setValues(values);
  rng.setNotes(notes);
}
function getEmailForCol_(sh, col){
  return String(sh.getRange(EMAIL_ROW, col).getValue() || '').trim();
}

/***** UTILITIES: CALENDAR + GENERAL *****/
function getHeaderMaps_(sh){
  var lastCol = sh.getLastColumn();
  var names = {};
  var emails = {};
  var nameValues = sh.getRange(NAME_ROW, 1, 1, lastCol).getValues()[0];
  var emailValues = sh.getRange(EMAIL_ROW, 1, 1, lastCol).getValues()[0];
  var knownEmailsSet = {};
  for (var c = 1; c <= lastCol; c++){
    names[c] = String(nameValues[c-1] || '').trim();
    var e = String(emailValues[c-1] || '').trim();
    emails[c] = e;
    if (e) knownEmailsSet[e.toLowerCase()] = true;
  }
  return { names: names, emails: emails, knownEmailsSet: knownEmailsSet };
}
function stats_(created, updated, deleted, membershipsAdded, membershipsRemoved, skipped, summary){
  return { created: created, updated: updated, deleted: deleted, membershipsAdded: membershipsAdded, membershipsRemoved: membershipsRemoved, skipped: skipped, summary: summary };
}
function canonicalId_(id){
  id = String(id || '').trim();
  if (!id) return '';
  var at = id.indexOf('@');
  return at >= 0 ? id.substring(0, at) : id;
}
function parseEventIdFromNote_(note){
  try {
    var obj = JSON.parse(String(note || ''));
    return canonicalId_(obj && obj.eventId ? obj.eventId : '');
  } catch(_){
    return canonicalId_(String(note || '').trim());
  }
}
function parseTitleKeyFromNote_(note){
  try {
    var obj = JSON.parse(String(note || ''));
    var t = obj && obj.titleKey ? obj.titleKey : '';
    return normalizeKey_(t);
  } catch(_){
    return '';
  }
}
function getEventByIdSafe_(cal, id){
  if (!id) return null;
  try { var ev = cal.getEventById(id); if (ev) return ev; } catch(e){}
  if (id.indexOf('@') === -1) { try { return cal.getEventById(id + '@google.com'); } catch(e){} }
  return null;
}
function hasGuest_(ev, email){
  var list = ev.getGuestList() || [];
  var target = (email || '').toLowerCase();
  for (var i=0; i<list.length; i++){
    if ((list[i].getEmail() || '').toLowerCase() === target) return true;
  }
  return false;
}
function getAllDayEventsOn_(cal, dayStart){
  var d = new Date(dayStart.getFullYear(), dayStart.getMonth(), dayStart.getDate());
  var dayEnd = new Date(d.getFullYear(), d.getMonth(), d.getDate()+1);
  var evs = cal.getEvents(d, dayEnd);
  var out = [];
  for (var i=0; i<evs.length; i++){
    try { if (evs[i].isAllDayEvent && evs[i].isAllDayEvent()) out.push(evs[i]); } catch(e){}
  }
  return out;
}
function removeGuestAndDeleteIfEmpty_(ev, email){
  try { ev.removeGuest(email); } catch(_){ }
  var remaining = ev.getGuestList() || [];
  if (remaining.length === 0){
    try { ev.deleteEvent(); return true; } catch(_) {}
  }
  return false;
}
function findEventOnDayByTitle_(cal, dayStart, titleKey){
  var dayEnd = new Date(dayStart.getFullYear(), dayStart.getMonth(), dayStart.getDate()+1);
  var evs = cal.getEvents(dayStart, dayEnd);
  for (var i=0; i<evs.length; i++){
    try{
      var ev = evs[i];
      if (!(ev.isAllDayEvent && ev.isAllDayEvent())) continue;
      var tKey = normalizeKey_(collapseWhitespace_(ev.getTitle()||''));
      if (tKey === titleKey) return ev;
    }catch(e){}
  }
  return null;
}
function eventAppearsInOtherGroups_(ev, groups, currentKey){
  if (!ev) return false;
  var id = canonicalId_(ev.getId());
  for (var k in groups){
    if (!groups.hasOwnProperty(k) || k === currentKey) continue;
    var mems = groups[k].members;
    for (var i=0;i<mems.length;i++){
      var mev = mems[i].event;
      if (mev && canonicalId_(mev.getId()) === id) return true;
    }
  }
  return false;
}
function dateKey_(d){
  var y = d.getFullYear();
  var m = d.getMonth()+1; if (m<10) m='0'+m;
  var day = d.getDate(); if (day<10) day='0'+day;
  return y + '-' + m + '-' + day;
}
function asDate_(v){
  if (!v) return null;
  if (Object.prototype.toString.call(v) === '[object Date]') return v;
  var d = new Date(v);
  return isNaN(d) ? null : d;
}
function equalsIgnoreCase_(a,b){ return String(a).trim().toLowerCase() === String(b).trim().toLowerCase(); }
function sameDay_(a,b){ return a && b && a.getFullYear()===b.getFullYear() && a.getMonth()===b.getMonth() && a.getDate()===b.getDate(); }
function normalizeKey_(s){
  if (!s) return '';
  var t = String(s).trim();
  t = t.replace(/[\u2012\u2013\u2014\u2015]+/g, '-');
  t = t.replace(/\s+/g, ' ');
  return t.toLowerCase();
}
function collapseWhitespace_(s){
  if (!s) return '';
  var t = String(s);

  // Normalize clipboard gremlins
  t = t.replace(/[\u200B-\u200D\uFEFF]/g, ''); // zero-width
  t = t.replace(/\u00A0/g, ' ');               // NBSP → space

  t = t.trim();
  t = t.replace(/[\u2012\u2013\u2014\u2015]+/g, '-'); // unify dashes
  t = t.replace(/\s+/g, ' ');                         // collapse whitespace
  return t;
}
function toast_(msg){ SpreadsheetApp.getActiveSpreadsheet().toast(msg,'Scheduler',5); }
function deleteTriggersByHandler_(name){
  var removed = 0;
  var triggers = ScriptApp.getProjectTriggers();
  for (var i = 0; i < triggers.length; i++) {
    if (triggers[i].getHandlerFunction() === name) { ScriptApp.deleteTrigger(triggers[i]); removed++; }
  }
  return removed;
}
function findOrCreateRowForDate_(day){
  var sh = getSheet_();
  var last = sh.getLastRow();
  for (var r = DATA_START_ROW; r <= last; r++){
    var v = asDate_(sh.getRange(r,1).getValue());
    if (v && sameDay_(v, day)) return r;
  }
  var newRow = last + 1;
  sh.getRange(newRow, 1).setValue(day);
  return newRow;
}
function pruneDeletedEventRefsForRow_(row, cal, emailsMap, skipColsSet){
  var sh = getSheet_();
  var lastCol = sh.getLastColumn();
  for (var c = 2; c <= lastCol; c++){
    var email = (emailsMap[c] || '').trim().toLowerCase();
    if (!email) continue;

    var cell = sh.getRange(row, c);
    var note = String(cell.getNote() || '').trim();
    if (!note) continue;

    var eventId = parseEventIdFromNote_(note);
    if (!eventId) { cell.setNote(''); continue; }

    var ev = getEventByIdSafe_(cal, eventId);
    var stillGuest = false;
    if (ev){
      var guests = ev.getGuestList() || [];
      for (var i=0; i<guests.length; i++){
        if ((guests[i].getEmail() || '').toLowerCase() === email) { stillGuest = true; break; }
      }
    }

    var isEditedCol = !!(skipColsSet && skipColsSet[c]);

    if (!ev || !stillGuest) {
      if (isEditedCol) {
        // User just pasted/typed here: drop the stale note but PRESERVE the value
        cell.setNote('');
        // Also mark sticky to prevent inbound override for a short time
        try {
          var rowDate = asDate_(sh.getRange(row,1).getValue());
          if (rowDate) addSticky_(dateKey_(new Date(rowDate.getFullYear(), rowDate.getMonth(), rowDate.getDate())), email, CHANGE_STICKY_MINUTES);
        } catch(_){ }
      } else {
        // Clear value+note only when not part of the current edit pass
        cell.setValue('');
        cell.setNote('');
      }
    }
  }
}
function canUseAdvancedCalendar_(){
  return typeof Calendar !== 'undefined' && Calendar && Calendar.Events && typeof Calendar.Events.list === 'function';
}
function daysSince_(iso){
  if (!iso) return 1e9;
  var then = new Date(iso).getTime();
  return (Date.now() - then) / 86400000;
}

// ===== Re-creation suppression helpers =====
function suppressionKey_(dayKey, titleKey, emailLower){
  return [String(dayKey||'').trim(), String(titleKey||'').trim(), String((emailLower||'').toLowerCase().trim())].join('|');
}
function loadSuppression_(){
  try{
    var raw = PropertiesService.getScriptProperties().getProperty(RECREATE_SUPPRESS_PROP) || '{}';
    var obj = JSON.parse(raw);
    return obj && typeof obj === 'object' ? obj : {};
  }catch(_){ return {}; }
}
function saveSuppression_(obj){
  var now = Date.now();
  var filtered = {};
  var items = [];
  for (var k in obj){
    if (!obj.hasOwnProperty(k)) continue;
    var rec = obj[k] || {};
    var exp = Number(rec.exp)||0;
    if (exp > now){ filtered[k] = { exp: exp }; items.push({ k: k, exp: exp }); }
  }
  if (items.length > RECREATE_SUPPRESS_MAX){
    items.sort(function(a,b){ return a.exp - b.exp; });
    var drop = items.length - RECREATE_SUPPRESS_MAX;
    for (var i=0; i<drop; i++){
      delete filtered[items[i].k];
    }
  }
  PropertiesService.getScriptProperties().setProperty(RECREATE_SUPPRESS_PROP, JSON.stringify(filtered));
}
function addSuppression_(dayKey, titleKey, emailLower, hours){
  var dk = String(dayKey||'').trim();
  var tk = normalizeKey_(titleKey||'');
  var el = String(emailLower||'').toLowerCase().trim();
  if (!dk || !tk || !el) return;
  var map = loadSuppression_();
  var ttlHrs = Math.max(1, Number(hours||RECREATE_SUPPRESS_HOURS));
  map[suppressionKey_(dk, tk, el)] = { exp: Date.now() + ttlHrs*3600000 };
  saveSuppression_(map);
}
function isCreationSuppressed_(dayKey, titleKey, emailLower){
  var dk = String(dayKey||'').trim();
  var tk = normalizeKey_(titleKey||'');
  var el = String(emailLower||'').toLowerCase().trim();
  if (!dk || !tk || !el) return false;
  var map = loadSuppression_();
  var key = suppressionKey_(dk, tk, el);
  var rec = map[key];
  if (!rec) return false;
  var now = Date.now();
  var exp = Number(rec.exp)||0;
  if (exp <= now){
    delete map[key];
    saveSuppression_(map);
    return false;
  }
  return true;
}
